/*
6、新约瑟夫游戏
【问题描述】
一个皆大欢喜的新游戏：假设 n个人站成一圈，从第 1 人开始交替的去掉游戏者，
但只是暂时去掉（例如，首先去掉 2），直到最后剩下唯一的幸存者为止。幸存
者选出后，所有比幸存者号码高的人每人将得到 1 块钱，并且永久性地离开，
其余剩下的人将重复以上过程，比幸存者号码高的人每人将得到 1 块钱后离开。
一旦经过这样的过程后，人数不再减少，最后剩下的那些人将得到 2 块钱。请
计算一下组织者一共要付出多少钱？
如图 9.4-5 所示，第一轮有 5 人，幸存者是 3，所以 4、5 得到 1 块钱后离
开，下一轮幸存者仍然是 3，因此没有人离开，所以每人得到 2 块钱，总共要付
出 2+2×3=8 块钱。
【输入格式】
一行一个整数 n，不超过 32767。
【输出格式】
一行一个整数，不超过 65535，表示总共要付出多少钱。
【输入样例】
10
【输出样例】
13
*/
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+10;
int n;
int a[N];
int main(){

	return 0;
}
/*
【问题分析】
“约瑟夫”问题有很多种变形，这是其中的一种。首先，每个人都会得到1块
钱，只有最后的那些幸存者多得到了1块钱。所以，我们只要求出最后会幸存几个
人便行了。假设经过m次出圈操作后还剩final(m)个人，此时人数不再减少了，则问
题的解应该为：final(m)+ n。如何求final(m)呢？显然，当第i次的final(i)=i时，人数
就不会再减少了，此时的i即为m；否则，我们就需要对剩下的final(i)个人再进行报
数出圈操作。
设jose(i)表示i个人的圈报数后的幸存者编号，设报到k的人出去，则jose(i-1)可
以理解为第一轮第一次报数，k出去后的状态。如图9.4-6所示左图，k出去后会从
k+1继续报数，此时圈中有i-1个人，从k+1开始报数，编号jose(i)为：k+1，
k+2，… i ，1，2，…k-1。
我们可以人为地把这个圈逆时针
转k个单位，即变成图9.4-6所示
右图的状态，此时报数的编号
jose(i-1)：1，2，…i-k ，i-k+1，
i-k+2，…i-1。
观察以上两个序列发现，除了加边框的两个数据外，其它所有数据都满足下
列规律：jose(i)=(jose(i-1)+ k) mod i。对这个式子稍做调整，变成如下公式就都满
足了：jose(i)=(jose(i-1)+1) mod i + 1。
至此，我们就找到了问题的递推关系式，边界条件也很明显，就是jose(1)=1。
然后，顺推求出每个jose(i)，直到某一次jose(i)=i,则final(i)赋值为i，否则，final(i)赋
值为final(jose(i))。
*/

