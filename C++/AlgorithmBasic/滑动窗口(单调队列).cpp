/*
单调队列 求滑动窗口中的最大/小值 
*/
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+5;
int a[N],q[N];
int n,k;
int main(){
	cin>>n>>k;
	for(int i=0;i<n;i++)scanf("%d",a+i);
	//找最小值,0初始化滑动窗口队列
	int hh=0,tt=-1;//当队头hh大于队尾tt时, 滑动窗口队列为空
	//枚举原本队列 
	for(int i=0;i<n;i++){
		//若当前队不空且队头元素不在当前窗口内(范围:[i-k+1,i]一共k个数) 
		//队头出队(队头元素滑出窗口)
		if(hh<=tt&&q[hh]<i-k+1)hh++; 
        //若当前队不空且队尾元素比当前元素要更优
		//(若当前是找最小值,则当前元素比队尾元素更小时为更优) 
        //队尾入队
        while(hh<=tt&&a[q[tt]]>=a[i])tt--;
        //当前元素作为入队作为新队尾(存储下标)
        q[++tt]=i;
        //当i>=k-1时才开始输出答案,例如 窗口大小为3 在i为2时才能有答案输出,否则不构成滑动窗口 
        if(i>=k-1)printf("%d ",a[q[hh]]);
	}
	puts("");
	
	//找最大值 
	hh=0,tt=-1;//当队头hh大于队尾tt时, 滑动窗口队列为空
	//枚举原本队列 
	for(int i=0;i<n;i++){
		//若当前队不空且队头元素不在当前窗口内(范围:[i-k+1,i]一共k个数) 
		//队头出队(队头元素滑出窗口)
		if(hh<=tt&&q[hh]<i-k+1)hh++; 
        //若当前队不空且队尾元素比当前元素要更优
		//(当前是找最大值,则当前元素比队尾元素更大时为更优) 
        //队尾入队
        while(hh<=tt&&a[q[tt]]<=a[i])tt--;
        //当前元素作为入队作为新队尾(存储下标)
        q[++tt]=i;
        //当i>=k-1时才开始输出答案,例如 窗口大小为3 在i为2时才能有答案输出,否则不构成滑动窗口 
        if(i>=k-1)printf("%d ",a[q[hh]]);
	}
	return 0;
}
